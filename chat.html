<!DOCTYPE html>
<html lang="ja">
<head>
    <link rel="icon" href="icon.png" type="image/x-icon">
<meta charset="UTF-8">
<title>チャット</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="ページの説明">
<meta name="keywords" content="ページのキーワードA,B,C">
<link rel="stylesheet" href="index.css">
<meta charset="UTF-8" />
<title>チャット</title>
<style>
  body { font-family: sans-serif; max-width: 600px; margin: auto; }
  #messages div {
    display: block;
    border-bottom: 1px solid #ccc;
    margin: 8px 0;
    padding: 4px;
    position: relative;
  }
  .message-info {
    white-space: nowrap;
    font-weight: bold;
    user-select: none;
    display: inline-block;
    margin-right: 8px;
  }
  .message-content {
    white-space: pre-wrap;
    display: inline-block;
    vertical-align: middle;
    max-width: 70%;
    word-break: break-word;
  }
  .timestamp {
    color: #666;
    font-size: 0.75em;
    margin-left: 8px;
    user-select: none;
  }
  .delete-btn {
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    color: #c00;
    font-size: 14px;
    cursor: pointer;
    padding: 0 6px;
    line-height: 1;
  }
  .delete-btn:hover {
    color: #f00;
  }
  img {
    max-width: 200px;
    display: block;
    margin-top: 4px;
  }
  input, button {
    box-sizing: border-box;
  }
  #chat {
    display: none;
  }
  #partner-list {
    margin-bottom: 12px;
  }
  #partner-list span {
    display: inline-flex;
    align-items: center;
    background: #eee;
    padding: 4px 8px;
    margin: 0 6px 6px 0;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    position: relative;
  }
  #partner-list span.selected {
    background: #b4d5ff;
    font-weight: bold;
  }
  #partner-list .remove-btn {
    margin-left: 6px;
    font-weight: bold;
    color: #900;
    cursor: pointer;
    user-select: none;
    font-size: 14px;
    line-height: 1;
  }
  #partner-list .remove-btn:hover {
    color: #f00;
  }
  #partner-add {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
  }
  #partner-add input {
    flex-grow: 1;
    padding: 8px;
  }
  /* 投稿送信バー全体 */
  #send-bar {
    display: flex;
    align-items: center;
    background-color: #222; /* 黒寄りのグレー */
    padding: 6px 10px;
    border-radius: 6px;
    gap: 8px;
    margin-top: 12px;
  }
 
  /* メッセージ入力欄 */
  #msg {
    flex-grow: 1;
    padding: 8px;
    height: 3em; /* 2行分くらい */
    resize: none;
    border-radius: 4px;
    border: none;
    font-size: 1em;
    line-height: 1.4em;
  }
  /* 送信ボタン */
  #send-btn {
    background-color: #444;
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
  #send-btn:hover {
    background-color: #666;
  }
   #call-btn {
    background-color: #444;
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
   #logout-btn {
    background-color: #444;
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js" defer></script>
</head>
<body>
    <div id="outer">
<header><div id="header-inner"><h1>watatawa Software</h1><a href="index.html">トップページ</a>   <a href="download.html">ダウンロード</a>   <a href="post.html">掲示板</a>   <a href="guff.html">ガフ札情報</a>  <a href="guffimage.html">ガフの写真集</a>  <a href="chat.html">チャット</a></header>
<main><div id="text">
<h2>個人チャット</h2>

<div id="auth">
  <input id="nickname" placeholder="ニックネーム" />
  <input id="password" type="password" placeholder="パスワード" />
  <button id="signup-btn">新規登録</button>
  <button id="login-btn">ログイン</button>
</div>

<div id="chat">
  <p>あなたのニックネーム: <span id="my-nickname"></span></p> <button id="logout-btn">ログアウト</button>

  <div id="partner-add">
    <input id="new-partner" placeholder="ニックネームで追加" />
    <button id="add-partner-btn">追加</button>
  </div>
  <div id="call-popup" style="display:none; position:fixed; top:20%; left:50%; transform:translateX(-50%);
 background:white; border:1px solid #ccc; padding:20px; text-align:center; z-index:9999;">
  <div id="call-status">接続中...</div>
  <div id="call-timer"></div>
  <button id="end-call-btn" style="margin-top:10px;">通話終了</button>
</div>

  <div id="partner-list" title="トーク相手を変更"></div>

  <p>To: <span id="current-partner"></span></p>

  <p id="unread-badge" style="color: red;"></p>

  <div id="messages"></div>
 
  <input id="msg" placeholder="メッセージ" />

  <button id="send-btn">送信</button>
   <input type="file" id="file" />
 <button id="call-btn">音声通話を開始</button>
</div>

</div>
</main>
<aside>
<div class="side-title">menu</div>
<div class="side">
<ul>
    <audio id="call-audio" src="call.mp3" preload="auto"></audio>

 

</ul>
</div>
</aside>
<footer>all rights reserved ©watatawa Software 2021~2025</footer>

<script defer>
document.addEventListener("DOMContentLoaded", () => {
  const supabaseUrl = "https://mbjvhxpozxylwcemnbcr.supabase.co";
  const supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ianZoeHBvenh5bHdjZW1uYmNyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxMzM3MzAsImV4cCI6MjA2NzcwOTczMH0.JddcQ5SoHfR-OWGma__X8iP0OphdnLHOPdYjm3Ca2Qo";
  const supabaseClient = supabase.createClient(supabaseUrl, supabaseAnonKey);

  let currentUser = null;
  let currentPartner = null;
  let messagePolling = null;
  let partners = [];

  // DOM Elements
  const partnerListEl = document.getElementById("partner-list");
  const currentPartnerEl = document.getElementById("current-partner");
  const unreadBadgeEl = document.getElementById("unread-badge");

  document.getElementById("signup-btn").onclick = signup;
  document.getElementById("login-btn").onclick = login;
  document.getElementById("send-btn").onclick = sendMessage;
  document.getElementById("logout-btn").onclick = logout;
  document.getElementById("add-partner-btn").onclick = addPartner;

  // ローカルストレージに保存していたuser情報を復元するがパートナーはDBから取得する
  const storedUser = localStorage.getItem("user");
  if (storedUser) {
    currentUser = JSON.parse(storedUser);
    showChat();
    loadPartnersFromDB();
  }

  function insertLineBreaks(text, maxLen = 30) {
    const regex = new RegExp(`.{1,${maxLen}}`, 'g');
    return (text.match(regex) || []).join('\n');
  }

  async function signup() {
    const nickname = document.getElementById("nickname").value.trim();
    const password = document.getElementById("password").value;
    if (!nickname || !password) return alert("ニックネームとパスワードを入力してください");

    const { data: exists, error: existsErr } = await supabaseClient
      .from("users")
      .select("id")
      .eq("nickname", nickname)
      .single();
    if (exists) return alert("ニックネームは既に使われています");
    if (existsErr && existsErr.code !== 'PGRST116') return alert("登録エラー：" + existsErr.message);

    const { error } = await supabaseClient
      .from("users")
      .insert({ nickname, password });

    if (error) return alert("登録失敗: " + error.message);
    alert("登録成功！ログインしてください");
  }

  async function login() {
    const nickname = document.getElementById("nickname").value.trim();
    const password = document.getElementById("password").value;
    if (!nickname || !password) return alert("ニックネームとパスワードを入力してください");

    const { data, error } = await supabaseClient
      .from("users")
      .select("*")
      .eq("nickname", nickname)
      .eq("password", password)
      .single();

    if (error || !data) return alert("ログイン失敗: ニックネームまたはパスワードが間違っています");

    currentUser = data;
    localStorage.setItem("user", JSON.stringify(currentUser));
    showChat();
    loadPartnersFromDB();
  }

  function showChat() {
    document.getElementById("auth").style.display = "none";
    document.getElementById("chat").style.display = "block";

    document.getElementById("my-nickname").textContent = currentUser.nickname;

    if (messagePolling) clearInterval(messagePolling);
    messagePolling = setInterval(loadMessages, 1000);
  }

  async function sendMessage() {
    if (!currentPartner) return alert("会話する相手を選択してください");

    const content = document.getElementById("msg").value.trim();
    if (!content && !document.getElementById("file").files.length) return alert("メッセージか画像を入力してください");

    const { data: toUser, error: toError } = await supabaseClient
      .from("users")
      .select("*")
      .eq("nickname", currentPartner)
      .single();

    if (toError || !toUser) return alert("相手のニックネームが見つかりません");

    let image_url = null;
    const fileInput = document.getElementById("file");
    if (fileInput.files.length > 0) {
      const file = fileInput.files[0];
      const path = `${currentUser.id}/${Date.now()}-${file.name}`;
      const { error: uploadError } = await supabaseClient.storage
        .from("chat-images")
        .upload(path, file);

      if (uploadError) return alert("画像アップロード失敗: " + uploadError.message);

      const { data: urlData } = supabaseClient.storage
        .from("chat-images")
        .getPublicUrl(path);

      image_url = urlData.publicUrl;
    }

    const { error } = await supabaseClient
      .from("messages")
      .insert({
        sender_id: currentUser.id,
        receiver_id: toUser.id,
        content,
        image_url
      });

    if (error) return alert("メッセージ送信失敗: " + error.message);

    document.getElementById("msg").value = "";
    fileInput.value = "";

    await addPartnerToDB(currentPartner);
    loadMessages();
  }

  async function loadMessages() {
    if (!currentPartner) return;

    const { data: toUser } = await supabaseClient
      .from("users")
      .select("*")
      .eq("nickname", currentPartner)
      .single();

    if (!toUser) return;

    const { data, error } = await supabaseClient
      .from("messages")
      .select("*")
      .or(`sender_id.eq.${currentUser.id},receiver_id.eq.${currentUser.id}`)
      .order("created_at", { ascending: true });

    if (error) return console.error(error);

    const filtered = data.filter(msg =>
      (msg.sender_id === currentUser.id && msg.receiver_id === toUser.id) ||
      (msg.sender_id === toUser.id && msg.receiver_id === currentUser.id)
    );

    const box = document.getElementById("messages");
    box.innerHTML = "";

    let unreadCount = 0;

    for (const msg of filtered) {
      const div = document.createElement("div");

      const senderLabel = msg.sender_id === currentUser.id ? "自分" : "相手";
      const messageText = insertLineBreaks(msg.content || "", 30);
      const timestamp = new Date(msg.created_at).toLocaleString();

      div.innerHTML = `
        <span class="message-info">${senderLabel}</span>
        <span class="message-content">${messageText}</span>
        <span class="timestamp">${timestamp}</span>
      `;

      if (msg.image_url) {
        const img = document.createElement("img");
        img.src = msg.image_url;
        div.appendChild(img);
      }

      if (msg.sender_id === currentUser.id) {
        const btn = document.createElement("button");
        btn.className = "delete-btn";
        btn.textContent = "✖";
        btn.title = "メッセージを削除";
        btn.onclick = () => deleteMessage(msg.id);
        div.appendChild(btn);
      }

      box.appendChild(div);

      // 簡易未読判定
      if (msg.receiver_id === currentUser.id && !msg.read) {
        unreadCount++;
      }
    }

    unreadBadgeEl.textContent = unreadCount > 0 ? `未読メッセージ: ${unreadCount}` : "";
  }

  async function deleteMessage(id) {
    const { error } = await supabaseClient
      .from("messages")
      .delete()
      .eq("id", id)
      .eq("sender_id", currentUser.id);

    if (error) return alert("削除失敗: " + error.message);

    loadMessages();
  }

  // パートナー一覧をDBから取得
  async function loadPartnersFromDB() {
    if (!currentUser) return;

    const { data, error } = await supabaseClient
      .from("user_partners")
      .select("partner_nickname")
      .eq("user_id", currentUser.id);

    if (error) {
      console.error(error);
      return;
    }

    partners = data.map(p => p.partner_nickname);
    renderPartnerList();

    if (partners.length > 0 && !currentPartner) {
      setCurrentPartner(partners[0]);
    } else if (partners.length === 0) {
      setCurrentPartner(null);
    }
  }

  // パートナー一覧をDBに追加（重複チェックはDBのユニーク制約に任せる）
  async function addPartnerToDB(nick) {
    if (!currentUser) return;
    if (!nick || partners.includes(nick) || nick === currentUser.nickname) return;

    const { error } = await supabaseClient
      .from("user_partners")
      .insert({ user_id: currentUser.id, partner_nickname: nick });

    if (error) {
      if (error.code === "23505") {
        // 重複エラーは無視
      } else {
        alert("パートナー追加失敗: " + error.message);
      }
      return;
    }

    partners.push(nick);
    renderPartnerList();
  }

  // パートナー一覧描画（削除ボタン付き）
  function renderPartnerList() {
    partnerListEl.innerHTML = "";
    partners.forEach((p, i) => {
      const sp = document.createElement("span");
      sp.textContent = p;
      sp.className = (p === currentPartner) ? "selected" : "";
      sp.onclick = () => setCurrentPartner(p);

      const delBtn = document.createElement("button");
      delBtn.textContent = "✖";
      delBtn.title = "パートナーを削除";
      delBtn.className = "del-partner-btn";
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`「${p}」をトークルームから削除しますか？（受信するには再度追加する必要があります）`)) return;

        const { error } = await supabaseClient
          .from("user_partners")
          .delete()
          .eq("user_id", currentUser.id)
          .eq("partner_nickname", p);

        if (error) {
          alert("削除失敗: " + error.message);
          return;
        }

        partners.splice(i, 1);
        renderPartnerList();

        if (currentPartner === p) {
          if (partners.length > 0) {
            setCurrentPartner(partners[0]);
          } else {
            setCurrentPartner(null);
            document.getElementById("messages").innerHTML = "";
            unreadBadgeEl.textContent = "";
          }
        }
      };

      sp.appendChild(delBtn);
      partnerListEl.appendChild(sp);
    });
  }

  function setCurrentPartner(nick) {
    currentPartner = nick;
    currentPartnerEl.textContent = nick || "";
    renderPartnerList();
    loadMessages();
  }

  function addPartner() {
    const input = document.getElementById("new-partner");
    const val = input.value.trim();
    if (!val) return alert("相手のニックネームを入力してください");
    if (val === currentUser.nickname) return alert("自分のニックネームは追加できません");
    if (partners.includes(val)) return alert("すでにリストにあります");

    addPartnerToDB(val);
    input.value = "";
  }

  function logout() {
    currentUser = null;
    currentPartner = null;
    partners = [];
    localStorage.removeItem("user");
    document.getElementById("chat").style.display = "none";
    document.getElementById("auth").style.display = "block";
    document.getElementById("messages").innerHTML = "";
    document.getElementById("my-nickname").textContent = "";
    currentPartnerEl.textContent = "";
    unreadBadgeEl.textContent = "";
    document.getElementById("nickname").value = "";
    document.getElementById("password").value = "";
    document.getElementById("msg").value = "";
    document.getElementById("new-partner").value = "";
    if (messagePolling) clearInterval(messagePolling);
  }
  let localStream = null;
  let peerConnection = null;
  let callChannel = null;
  const callAudio = document.getElementById("call-audio");
  const callPopup = document.getElementById("call-popup");
  const callStatus = document.getElementById("call-status");
  const callTimerEl = document.getElementById("call-timer");
  let callTimerInterval = null;

  document.getElementById("call-btn").onclick = startCall;
  document.getElementById("end-call-btn").onclick = endCall;

  // 発信処理
async function startCall() {
  if (!currentPartner) return alert("通話相手を選択してください");

  const { data: partnerUser } = await supabaseClient
    .from("users")
    .select("*")
    .eq("nickname", currentPartner)
    .single();
  if (!partnerUser) return alert("相手が見つかりません");

  await prepareCallConnection(true);

  // offer を作成し、calls に登録
  const offer = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offer);

  // 重複通話を避けるため削除（任意）
  await supabaseClient.from("calls")
    .delete()
    .eq("caller_id", currentUser.id)
    .eq("callee_id", partnerUser.id);

  await supabaseClient.from("calls").insert({
    caller_id: currentUser.id,
    callee_id: partnerUser.id,
    type: "offer",
    sdp_offer: JSON.stringify(offer)
  });

  showCallPopup("発信中...");
  callAudio.play();
}

async function prepareCallConnection(isCaller) {
  peerConnection = new RTCPeerConnection();

  localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

peerConnection.ontrack = event => {
  const remoteAudio = document.createElement("audio");
  remoteAudio.srcObject = event.streams[0];
  remoteAudio.autoplay = true;
  remoteAudio.controls = true; // デバッグ時に可視化
  document.body.appendChild(remoteAudio); // DOMに追加しておく
};


  peerConnection.onicecandidate = async (event) => {
    if (event.candidate) {
      await supabaseClient.from("calls").insert({
        caller_id: currentUser.id,
        callee_id: currentPartner.id,
        type: "ice",
        candidate: JSON.stringify(event.candidate)
      });
    }
  };
}

function showCallPopup(status) {
  callStatus.textContent = status;
  callTimerEl.textContent = "";
  callPopup.style.display = "block";
  let seconds = 0;
  callTimerInterval = setInterval(() => {
    seconds++;
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    callTimerEl.textContent = `通話時間: ${min}:${sec.toString().padStart(2, "0")}`;
  }, 1000);
}

function endCall() {
  if (peerConnection) peerConnection.close();
  if (localStream) localStream.getTracks().forEach(track => track.stop());
  peerConnection = null;
  localStream = null;

  callAudio.pause();
  callAudio.currentTime = 0;

  callPopup.style.display = "none";
  clearInterval(callTimerInterval);
}
supabaseClient.channel("calls")
  .on("postgres_changes", {
    event: "INSERT",
    schema: "public",
    table: "calls"
  }, async payload => {
    const call = payload.new;

    if (call.callee_id !== currentUser.id) return; // 自分宛のみ処理

    // 着信：オファー受信
    if (call.type === "offer" && call.sdp_offer) {
      const callerUser = await supabaseClient
        .from("users")
        .select("*")
        .eq("id", call.caller_id)
        .single();

        callAudio.pause();  // 念のため停止
callAudio.currentTime = 0;
callAudio.play().catch(e => {
  console.warn("音声再生失敗:", e);
});


      const accept = confirm(`「${callerUser.data.nickname}」から通話着信！受けますか？`);
      if (!accept) return;

      currentPartner = callerUser.data.nickname;
      await prepareCallConnection(false);

      const offer = JSON.parse(call.sdp_offer);
      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      callAudio.pause();             
callAudio.currentTime = 0;    

      await supabaseClient.from("calls").insert({
        caller_id: currentUser.id,
        callee_id: call.caller_id,
        type: "answer",
        sdp_answer: JSON.stringify(answer)
      });

      showCallPopup("通話中...");
    }

    // アンサー受信
    if (call.type === "answer" && call.sdp_answer && peerConnection) {
      const answer = JSON.parse(call.sdp_answer);
      await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        callAudio.pause();             // ← 追加
  callAudio.currentTime = 0;  
      showCallPopup("通話中...");
    }

    // ICE Candidate 受信
    if (call.type === "ice" && call.candidate && peerConnection) {
      const candidate = JSON.parse(call.candidate);
      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }
  }).subscribe();



  
});



</script>

</body>
</html>
